---
layout: single
published: true
title:  "[JAVA] 이항 연산자 "
categories: Java
date: 2024-01-29 17:51:45
toc: true
toc_sticky: true
tag:   
  - Java
  - 자바
  - 이항 연산자
---

이항 연산자는 피연산자가 두 개인 연산자를 의미합니다.

## 산술 연산자 (+, -, *, /, %)

산술 연산자는 사칙연산과 유사합니다.

| 산술 연산자 | 설명 |
| --- | --- |
| + | 덧셈 |
| - | 뺄셈 |
| * | 곱셈 |
| / | 나눗셈 |
| % | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 나머지 |

```java
int a = 10;
int b = 3;

System.out.println(a + b);  // 13
System.out.println(a - b);  // 7
System.out.println(a * b);  // 30
System.out.println(a / b);  // 3
System.out.println(a % b);  // 1
```

`%` 연산자가 생소하실텐데 나눗셈을 수행하고 몫이 아닌 나머지를 돌려주는 연산자입니다. 10 나누기 3은 몫이 3이고 나머지는 1이므로, `10 % 3 == 1` 입니다.

만약 피연산자들의 타입이(byte, int, long, double, …) 동일하지 않다면 아래와 같은 규칙으로 연산이 됩니다.

1. 피연산자들이 모두 int보다 크기가 작을 경우 int로 변환 후 연산
    1. byte + byte → int + int
2. 피연산자 중에 long 타입이 있을 경우 모두 long으로 변환 후 연산
    1. int + long → long + long
3. 피연산자 중에 float 혹은 double 타입이 있을 경우 크기가 큰 실수 타입으로 변환 후 연산
    1. int + float → float + float

위의 규칙에 따라 다음 코드는 에러가 발생합니다.

```java
byte a = 1;
byte b = 1;
byte c = a + b; // 에러. byte는 int로 변환 후 연산되기 때문
```

예제를 좀 더 살펴봅시다.

```java
int a = 10;
int b = 4;
int c = a / b;  // 2
double d = a / b;   // 2.0
```

10 나누기 4는 2.5 이지만 c 변수에는 소수점 이하 부분을 버리고 2라는 결과가 저장됩니다. 그럼 d처럼 double 타입을 사용하면 2.5가 저장될까요? 아닙니다. int 타입의 연산이기 때문에 결과는 2가 되고 2를 실수화하여 2.0이 저장됩니다.

만약 2.5를 결과로 얻고 싶다면 어떻게 해야할까요? 피연산자 중 하나가 실수 타입이면 됩니다. 규칙에 따르면 피연산자 중 실수 타입이 있으면 모두 실수 타입으로 변환 후 연산합니다.

```java
int a = 10;
int b = 4;
double c = (double)a / b;  // 2.5
```

char 타입도 산술 연산이 가능합니다. 예를 들어 `‘A’` 는 65라는 유니코드를 가지기 때문에 `‘A’ + 1` 은 66이 됩니다. 자바에서는 리터럴 간의 연산은 타입 변환 없이 계산하기 때문에 `‘A’ + 1` 은 유니코드 66에 해당하는 `‘B’` 가 됩니다.

```java
char c1 = 'A' + 1;   // 'B' (유니코드 66은 문자 B)
char c2 = 'A';
char c3 = c2 + 1;   // 에러
```

c3 변수의 경우 에러가 발생하는데 이유는 천천히 생각해보셨으면 합니다. 위의 규칙을 참고해주시면 됩니다.

### 오버플로우

```java
int a = 1000000;
int b = 1000000;
int c = a * b;

System.out.println(c);  // -727379968
```

위의 코드에서 곱셈의 결과가 엉뚱한 값임을 볼 수 있습니다. 이는 곱셈의 결과가 int 타입에 저장할 수 있는 범위를 초과하였기 때문입니다. 이와 같은 현상을 오버플로우라고 하며 int 타입을 long으로 수정하면(크기가 큰 타입으로 바꾸면) 해결할 수 있습니다.

### NaN, Infinity

NaN, Infinity는 실수 타입 연산 중에 발생할 수 있습니다.

```java
double a = 10;
double b = 0;

System.out.println(a / b);  // Infinity
System.out.println(a % b);  // NaN
```

NaN은 Not a Number이고, Infinity는 무한대라는 의미입니다. NaN 또는 Infinity가 연산의 결과로 나오면 다음 연산을 수행해서는 안됩니다. 이 값에 어떤 연산을 해도 NaN 또는 Infinity가 되기 때문입니다.

```java
double a = 10;
double b = 0;

System.out.println(a / b + 1);  // Infinity
System.out.println(a % b + 1);  // NaN
```

NaN, Infinity를 체크할 수 있는 방법은 아래와 같습니다. 

```java
double a = 10;
double b = 0;

System.out.println(Double.isInfinite(a / b));  // true
System.out.println(Double.isNaN(a % b));  // true
```

## 문자열 연결 연산자 (+)

`+` 연산자는 산술 연산자, 부호 연산자인 동시에 문자열 연결 연산자이기도 합니다. 피연산자 중 한쪽이 문자열이면 `+` 연산자는 문자열 연결 연산자로 사용되어 문자열을 결합합니다.

```java
String str1 = "Hello!";
String str2 = str1 + "Nice to meet you";

System.out.println(str2);  // Hello!Nice to meet you
```

만약 `+` 연산자를 이용하여 문자열과 숫자를 연결하면 어떻게 될까요? 문자열과 숫자가 혼합된 경우 왼쪽에서부터 오른쪽으로 연산이 진행됩니다.

```java
// 문자열 "Hello"와 123이 먼저 연산되어 "Hello123"이 되고,
// 이것을 다시 456과 연산하여 "Hello123456"이 됩니다.
System.out.println("Hello" + 123 + 456);  // Hello123456

// 숫자 123과 456이 먼저 연산되어 579가 되고,
// 이것을 문자열 "Hello"와 연산하여 "579Hello"가 됩니다.
System.out.println(123 + 456 + "Hello");  // 579Hello
```

## 비교 연산자 (<, <=, >, >=, ==, !=)

비교 연산자는 피연산자들을 비교하여 boolean 타입인 `true`, `false` 를 산출합니다.

크기 비교

| 연산식 | 설명 |
| --- | --- |
| A > B | A가 B보다 큰 지 검사 |
| A >= B | A가 B보다 크거나 같은지 검사 |
| A < B | A가 B보다 작은 지 검사 |
| A <= B | A가 B보다 작거나 같은지 검사 |

동등 비교

| 연산식 | 설명 |
| --- | --- |
| A == B | A와 B가 같은지 검사 |
| A != B | A와 B가 다른지 검사 |

만약 피연산자가 `char` 타입이면 유니코드 값으로 비교 연산을 수행합니다.

```java
('A' < 'B') -> (65 < 66)
```

비교 연산 시 연산을 수행하기 전에 둘 중에 크기가 더 큰 타입으로 일치시킵니다. 예를 들어 아래와 같이 `char` 타입과 `int` 타입을 비교할 때는 `int`로 타입을 일치시킨 후 비교합니다.

```java
'A' == 65  // true
10 == 10.0  // true (int타입인 10을 double 타입인 10.0으로 변환 후 비교)
```

아래의 예제는 double 타입과 float 타입을 비교합니다.

```java
0.1 == 0.1f  // false
```

오른쪽의 0.1f가 `double`로 변환되어 0.1 == 0.1 의 결과로 true가 되어야할 것 같지만 그렇지 않습니다. 그 이유는 모든 부동소수점 타입은 0.1을 정확히 표기할 수 없어서 0.1f는 0.1의 근사 값이(예를 들어 0.100000000149와 같은 값) 되기 때문입니다.

피연산자를 모두 `float` 타입으로 변환하거나 `int`로 변환하면 이런 문제를 해결할 수 있습니다.

```java
(float)0.1 == 0.1f  // true
(int)(0.1 * 10) == (int)(0.1f * 10)  // true
```

`String` 타입의 문자열은 대소 비교를 할 수 없고, 동등 비교는 할 수 있습니다. 다만 문자열이 같은지 다른지를 비교하는 용도로 사용할 때는 주의해야합니다. 아래의 예제로 확인해보겠습니다.

```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");

System.out.println(str1 == str2);  // true
System.out.println(str1 == str3);  // false
```

str1, str2, str3가 모두 동일한 문자열이지만 str1과 str2는 같고, str1과 str3는 다르다는 결과를 볼 수 있습니다. 자바는 문자열이 동일하다면 동일한 String 객체를 참조합니다. 그래서 str1과 str2는 동일한 `String` 객체의 주소 값을 가지고 있습니다. 반면 str3는 `new` 로 생성한 새로운 `String` 객체이므로 새로운 주소를 가지고 있습니다. 아래에 그림으로 표현하였습니다.

![image](https://github.com/BaxDailyGit/BaxDailyGit/assets/99312529/f1d47518-11d5-4f04-be17-5e708be5cfe2)

이와 같이 `String` 타입에 동등 연산을 할 경우 객체의 주소 값이 같은지 다른지를 확인합니다.

그렇다면 문자열 자체가 같은지 다른지 비교하려면 어떻게 해야할까요? `equals()` 메소드를 이용하면 됩니다.

```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");

System.out.println(str1.equals(str2));  // true
System.out.println(str1.equals(str3));  // true
```

## 논리 연산자 (&&, ||, &, |, ^, !)

논리 연산자는 조건식을 연결할 때 사용하는 연산자입니다. 

논리 연산자의 피연산자는 `boolean` 타입만 사용할 수 있으며 종류와 기능은 아래와 같습니다.

### AND (&&)

피연산자가 모두 true일 경우에만 결과가 true 입니다. 

| x | y | x && y |
| --- | --- | --- |
| true | true | true |
| true | false | false |
| false | true | false |
| false | false | false |

### OR (||)

피연산자 중 하나만 true이면 결과는 true 입니다. 

| x | y | x || y |
| --- | --- | --- |
| true | true | true |
| true | false | true |
| false | true | true |
| false | false | false |

### XOR (배타적 논리합)

피연산자가 하나는 true이고 다른 하나는 false일 경우에만 결과가 true 입니다.

| 연산식 | 결과 |
| --- | --- |
| true ^ true | false |
| true ^ false | true |
| false ^ false | false |

### NOT (논리 부정)

피연산자의 논리 값을 바꿉니다.

| 연산식 | 결과 |
| --- | --- |
| !true | false |
| !false | true |

다음의 문제를 보면서 논리연산자를 익혀봅시다. 

1. x는 5보다 크**고** 13보다 작다.
    - x > 5 그리고 x < 13으로 연결된 조건이므로 `**x > 5 && x < 13**` 으로 쓸 수 있습니다.
2. i는 2의 배수 **또는** 3의 배수이다. 
    - ‘또는’으로 두 조건이 연결되어있으므로 ‘||’(OR)을 사용하면 됩니다.

## 비트 연산자 (&, |, ^, ~, <<, >>, >>>)

데이터를 비트 단위로 연산할 때 사용합니다. 이진수로 표현이 가능한 `int` 타입만 비트 연산을 할 수 있습니다. (비트는 0과 1로 이루어져있습니다.)

### 비트 논리 연산자

비트 논리 연산자에는 `&`, `|`, `^`, `~` 가 있습니다. `&`, `|`, `^` 연산자는 피연산자가 boolean이면 일반 논리 연산자이고, 피연산자가 정수이면 비트 논리 연산자로 동작합니다. 

| x | y | x & y | x | y | x ^ y |
| --- | --- | --- | --- | --- |
| 1 | 1 | 1 | 1 | 0 |
| 1 | 0 | 0 | 1 | 1 |
| 0 | 1 | 0 | 1 | 1 |
| 0 | 0 | 0 | 0 | 0 |

**AND (논리곱)**

두 비트가 모두 1일 경우에만 결과가 1입니다.

| 연산식 | 결과 |
| --- | --- |
| 1 & 1 | 1 |
| 1 & 0 | 0 |
| 0 & 0 | 0 |

**OR (논리합)**

두 비트 중 하나만 1이면 결과가 1입니다.

| 연산식 | 결과 |
| --- | --- |
| 1 | 1 | 1 |
| 1 | 0 | 1 |
| 0 | 0 | 0 |

**XOR (배타적 논리합)**

두 비트 중 하나는 1이고 다른 하나는 0일 경우 결과가 1입니다.

| 연산식 | 결과 |
| --- | --- |
| 1 ^ 1 | 0 |
| 1 ^ 0 | 1 |
| 0 ^ 0 | 0 |

**NOT (논리 부정)**

0은 1로, 1은 0으로 바꿉니다.

| 연산식 | 결과 |
| --- | --- |
| ~1 | 0 |
| ~0 | 1 |

예를 들어 15와 30을 비트 논리 연산해봅시다. 15를 이진수로 표현하면 `01111` 이고, 30을 이진수로 표현하면 `11110` 입니다.

`01111` 과 `11110` 의 비트 논리 연산 결과는 아래와 같습니다.

논리곱 (&)

- `01111` & `11110` == `01110`

논리합 (|)

- `01111` & `11110` == `11111`

배타적 논리합 (^)

- `01111` & `11110` == `10001`

논리 부정 (~)

- ~`01111`  == `10000`

### 비트 이동 연산자(쉬프트 연산자)

비트 이동 연산자는 정수 데이터의 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산을 수행합니다. 비트를 좌측으로 이동하면 자릿수가 늘어나고, 우측으로 이동하면 자릿수가 줄어드는 효과겠죠. 

| 연산식 | 결과 |
| --- | --- |
| a << b | 정수 a의 각 비트를 b만큼 왼쪽으로 이동 (빈자리는 0으로 채워짐) |
| a >> b | 정수 a의 각 비트를 b만큼 오른쪽으로 이동 (빈자리는 최상위 부호 비트(MSB)와 같은 값으로 채워짐) |
| a >>> b | 정수 a의 각 비트를 b만큼 오른쪽으로 이동시키며, 새로운 비트는 전부 0으로 채워짐 |

정수 8을 왼쪽으로 2비트 이동시켜봅시다. 정수 8을 2진수로 표현하면 `00001000` 입니다.

![image](https://github.com/BaxDailyGit/BaxDailyGit/assets/99312529/d398b41e-cf51-482d-b274-e4c8bebe7f56)
출처: https://www.tcpschool.com/

비트 전체를 왼쪽으로 이동할 때 맨 왼쪽 2비트는 버려지고, 맨 오른쪽에 새로 생긴 2비트는 0으로 채워집니다. 연산 결과를 10진수로 변환해보면 32가 됨을 알 수 있습니다.

이번에는 정수 -8을 오른쪽으로 2비트 이동시켜봅시다.

![image](https://github.com/BaxDailyGit/BaxDailyGit/assets/99312529/4c20fa67-d1b9-445a-8138-102436bc497e)
출처: https://www.tcpschool.com/

비트 전체를 오른쪽으로 이동할 때 맨 오른쪽 2비트는 밀려서 버려지고, 맨 왼쪽에 새로 생긴 2비트는 최상위 부호비트(MSB)와 동일한 값으로 채워집니다. (최상위 부호비트가 0이면 양수, 1이면 음수입니다.) 연산 결과의 최상위 부호비트가 1이므로 2의 보수를 적용해보면 -2라는 값이 됨을 알 수 있습니다. (컴퓨터가 음수를 저장하기위해 2의 보수라는 방법을 사용합니다.)

이번에는 정수 -8을 `>>>` 연산자로 2비트 오른쪽으로 이동시켜봅시다.

![image](https://github.com/BaxDailyGit/BaxDailyGit/assets/99312529/42f0f450-e65a-416b-87de-b748e2fddc7c)
출처: https://www.tcpschool.com/

비트 전체를 오른쪽으로 이동할 때 맨 오른쪽 2비트는 밀려서 버려지고, 맨 왼쪽에 새로 생긴 2비트는 무조건 0으로 채워집니다. 맨 왼쪽 최상위 부호비트가 0이 되었기 때문에 음수였던 값이 양수로 바뀌었음을 알 수 있습니다.